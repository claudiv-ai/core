/**
 * Context manifest parser — parses `.claudiv/context.cdml` files.
 *
 * The context manifest maps scopes to code artifacts, interface contracts,
 * architectural facts, and tool directives.
 */
import { readFile } from 'fs/promises';
import { parseDocument } from 'htmlparser2';
import * as cheerio from 'cheerio';
/**
 * Parse a `.claudiv/context.cdml` file into a ContextManifest.
 */
export function parseContextManifest(content) {
    const dom = parseDocument(content, {
        lowerCaseAttributeNames: false,
        lowerCaseTags: false,
        recognizeSelfClosing: true,
    });
    const $ = cheerio.load(dom, { xmlMode: false });
    const root = $('claudiv-context');
    if (root.length === 0) {
        throw new Error('No <claudiv-context> element found');
    }
    const forFile = root.attr('for') || '';
    const autoGenerated = root.attr('auto-generated') === 'true';
    // Parse global section
    const global = parseGlobal($);
    // Parse scope sections
    const scopes = parseScopes($);
    return {
        forFile,
        autoGenerated,
        global,
        scopes,
    };
}
/**
 * Load and parse a context manifest from a file path.
 */
export async function loadContextManifest(filePath) {
    const content = await readFile(filePath, 'utf-8');
    return parseContextManifest(content);
}
/**
 * Serialize a ContextManifest back to CDML string.
 */
export function serializeContextManifest(manifest) {
    const lines = [];
    lines.push(`<claudiv-context for="${manifest.forFile}" auto-generated="${manifest.autoGenerated}">`);
    lines.push('');
    // Global section
    lines.push('  <global>');
    if (manifest.global.refs.length > 0) {
        lines.push('    <refs>');
        for (const ref of manifest.global.refs) {
            const attrs = [`file="${ref.file}"`, `role="${ref.role}"`];
            if (ref.lines)
                attrs.push(`lines="${ref.lines}"`);
            if (ref.keys)
                attrs.push(`keys="${ref.keys}"`);
            lines.push(`      <code ${attrs.join(' ')} />`);
        }
        lines.push('    </refs>');
    }
    if (manifest.global.facts.length > 0) {
        lines.push('    <facts>');
        for (const fact of manifest.global.facts) {
            const decisionAttr = fact.decision ? ` decision="${fact.decision}"` : '';
            lines.push(`      <fact${decisionAttr}>${fact.content}</fact>`);
        }
        lines.push('    </facts>');
    }
    lines.push('  </global>');
    lines.push('');
    // Scope sections
    for (const scope of manifest.scopes) {
        lines.push(`  <scope path="${scope.path}">`);
        // Interfaces
        if (scope.interfaces.fulfills.length > 0 || scope.interfaces.depends.length > 0) {
            lines.push('    <interfaces>');
            for (const f of scope.interfaces.fulfills) {
                lines.push(`      <fulfills fqn="${f.fqn}" />`);
            }
            for (const d of scope.interfaces.depends) {
                const attrs = [`fqn="${d.fqn}"`];
                if (d.facet)
                    attrs.push(`facet="${d.facet}"`);
                if (d.usage)
                    attrs.push(`usage="${d.usage}"`);
                lines.push(`      <depends ${attrs.join(' ')} />`);
            }
            lines.push('    </interfaces>');
        }
        // Refs
        if (scope.refs.length > 0) {
            lines.push('    <refs>');
            for (const ref of scope.refs) {
                const attrs = [`file="${ref.file}"`, `role="${ref.role}"`];
                if (ref.lines)
                    attrs.push(`lines="${ref.lines}"`);
                if (ref.keys)
                    attrs.push(`keys="${ref.keys}"`);
                lines.push(`      <code ${attrs.join(' ')} />`);
            }
            lines.push('    </refs>');
        }
        // Facts
        if (scope.facts.length > 0) {
            lines.push('    <facts>');
            for (const fact of scope.facts) {
                const decisionAttr = fact.decision ? ` decision="${fact.decision}"` : '';
                lines.push(`      <fact${decisionAttr}>${fact.content}</fact>`);
            }
            lines.push('    </facts>');
        }
        // Tools
        if (scope.tools.length > 0) {
            lines.push('    <tools>');
            for (const tool of scope.tools) {
                lines.push(`      <tool name="${tool.name}" scope="${tool.scope}" />`);
            }
            lines.push('    </tools>');
        }
        lines.push('  </scope>');
        lines.push('');
    }
    lines.push('</claudiv-context>');
    return lines.join('\n');
}
// ─── Internal Parsers ───────────────────────────────────────────
function parseGlobal($) {
    const globalEl = $('claudiv-context > global');
    return {
        refs: parseRefs($, globalEl),
        facts: parseFacts($, globalEl),
    };
}
function parseScopes($) {
    const scopes = [];
    $('claudiv-context > scope').each((_, el) => {
        const scopeEl = $(el);
        const path = scopeEl.attr('path') || '';
        const fulfills = [];
        scopeEl.find('interfaces > fulfills').each((_, f) => {
            const fqn = f.attribs?.fqn;
            if (fqn)
                fulfills.push({ fqn });
        });
        const depends = [];
        scopeEl.find('interfaces > depends').each((_, d) => {
            const attrs = d.attribs || {};
            if (attrs.fqn) {
                depends.push({
                    fqn: attrs.fqn,
                    facet: attrs.facet,
                    usage: attrs.usage,
                });
            }
        });
        scopes.push({
            path,
            interfaces: { fulfills, depends },
            refs: parseRefs($, scopeEl),
            facts: parseFacts($, scopeEl),
            tools: parseTools($, scopeEl),
        });
    });
    return scopes;
}
function parseRefs($, parent) {
    const refs = [];
    parent.find('refs > code').each((_, el) => {
        const attrs = el.attribs || {};
        if (attrs.file) {
            refs.push({
                file: attrs.file,
                role: attrs.role || 'unknown',
                lines: attrs.lines,
                keys: attrs.keys,
            });
        }
    });
    // Also handle <config> refs
    parent.find('refs > config').each((_, el) => {
        const attrs = el.attribs || {};
        if (attrs.file) {
            refs.push({
                file: attrs.file,
                role: attrs.role || 'config',
                keys: attrs.keys,
            });
        }
    });
    return refs;
}
function parseFacts($, parent) {
    const facts = [];
    parent.find('facts > fact').each((_, el) => {
        const factEl = $(el);
        const content = factEl.text().trim();
        const decision = el.attribs?.decision;
        if (content) {
            facts.push({ content, decision });
        }
    });
    return facts;
}
function parseTools($, parent) {
    const tools = [];
    parent.find('tools > tool').each((_, el) => {
        const attrs = el.attribs || {};
        if (attrs.name) {
            tools.push({
                name: attrs.name,
                scope: attrs.scope || '**',
            });
        }
    });
    return tools;
}
//# sourceMappingURL=context-parser.js.map