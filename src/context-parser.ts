/**
 * Context manifest parser — parses `.claudiv/context.cdml` files.
 *
 * The context manifest maps scopes to code artifacts, interface contracts,
 * architectural facts, and tool directives.
 */

import { readFile } from 'fs/promises';
import { parseDocument } from 'htmlparser2';
import * as cheerio from 'cheerio';
import type { Element } from 'domhandler';
import type {
  ContextManifest,
  ContextGlobal,
  ContextScope,
  ContextRef,
  ContextFact,
  ContextTool,
} from './types.js';

/**
 * Parse a `.claudiv/context.cdml` file into a ContextManifest.
 */
export function parseContextManifest(content: string): ContextManifest {
  const dom = parseDocument(content, {
    lowerCaseAttributeNames: false,
    lowerCaseTags: false,
    recognizeSelfClosing: true,
  });

  const $ = cheerio.load(dom, { xmlMode: false });

  const root = $('claudiv-context');
  if (root.length === 0) {
    throw new Error('No <claudiv-context> element found');
  }

  const forFile = root.attr('for') || '';
  const autoGenerated = root.attr('auto-generated') === 'true';

  // Parse global section
  const global = parseGlobal($);

  // Parse scope sections
  const scopes = parseScopes($);

  return {
    forFile,
    autoGenerated,
    global,
    scopes,
  };
}

/**
 * Load and parse a context manifest from a file path.
 */
export async function loadContextManifest(filePath: string): Promise<ContextManifest> {
  const content = await readFile(filePath, 'utf-8');
  return parseContextManifest(content);
}

/**
 * Serialize a ContextManifest back to CDML string.
 */
export function serializeContextManifest(manifest: ContextManifest): string {
  const lines: string[] = [];

  lines.push(`<claudiv-context for="${manifest.forFile}" auto-generated="${manifest.autoGenerated}">`);
  lines.push('');

  // Global section
  lines.push('  <global>');
  if (manifest.global.refs.length > 0) {
    lines.push('    <refs>');
    for (const ref of manifest.global.refs) {
      const attrs = [`file="${ref.file}"`, `role="${ref.role}"`];
      if (ref.lines) attrs.push(`lines="${ref.lines}"`);
      if (ref.keys) attrs.push(`keys="${ref.keys}"`);
      lines.push(`      <code ${attrs.join(' ')} />`);
    }
    lines.push('    </refs>');
  }
  if (manifest.global.facts.length > 0) {
    lines.push('    <facts>');
    for (const fact of manifest.global.facts) {
      const decisionAttr = fact.decision ? ` decision="${fact.decision}"` : '';
      lines.push(`      <fact${decisionAttr}>${fact.content}</fact>`);
    }
    lines.push('    </facts>');
  }
  lines.push('  </global>');
  lines.push('');

  // Scope sections
  for (const scope of manifest.scopes) {
    lines.push(`  <scope path="${scope.path}">`);

    // Interfaces
    if (scope.interfaces.fulfills.length > 0 || scope.interfaces.depends.length > 0) {
      lines.push('    <interfaces>');
      for (const f of scope.interfaces.fulfills) {
        lines.push(`      <fulfills fqn="${f.fqn}" />`);
      }
      for (const d of scope.interfaces.depends) {
        const attrs = [`fqn="${d.fqn}"`];
        if (d.facet) attrs.push(`facet="${d.facet}"`);
        if (d.usage) attrs.push(`usage="${d.usage}"`);
        lines.push(`      <depends ${attrs.join(' ')} />`);
      }
      lines.push('    </interfaces>');
    }

    // Refs
    if (scope.refs.length > 0) {
      lines.push('    <refs>');
      for (const ref of scope.refs) {
        const attrs = [`file="${ref.file}"`, `role="${ref.role}"`];
        if (ref.lines) attrs.push(`lines="${ref.lines}"`);
        if (ref.keys) attrs.push(`keys="${ref.keys}"`);
        lines.push(`      <code ${attrs.join(' ')} />`);
      }
      lines.push('    </refs>');
    }

    // Facts
    if (scope.facts.length > 0) {
      lines.push('    <facts>');
      for (const fact of scope.facts) {
        const decisionAttr = fact.decision ? ` decision="${fact.decision}"` : '';
        lines.push(`      <fact${decisionAttr}>${fact.content}</fact>`);
      }
      lines.push('    </facts>');
    }

    // Tools
    if (scope.tools.length > 0) {
      lines.push('    <tools>');
      for (const tool of scope.tools) {
        lines.push(`      <tool name="${tool.name}" scope="${tool.scope}" />`);
      }
      lines.push('    </tools>');
    }

    lines.push('  </scope>');
    lines.push('');
  }

  lines.push('</claudiv-context>');
  return lines.join('\n');
}

// ─── Internal Parsers ───────────────────────────────────────────

function parseGlobal($: cheerio.CheerioAPI): ContextGlobal {
  const globalEl = $('claudiv-context > global');

  return {
    refs: parseRefs($, globalEl),
    facts: parseFacts($, globalEl),
  };
}

function parseScopes($: cheerio.CheerioAPI): ContextScope[] {
  const scopes: ContextScope[] = [];

  $('claudiv-context > scope').each((_, el) => {
    const scopeEl = $(el as Element);
    const path = scopeEl.attr('path') || '';

    const fulfills: ContextScope['interfaces']['fulfills'] = [];
    scopeEl.find('interfaces > fulfills').each((_, f) => {
      const fqn = (f as Element).attribs?.fqn;
      if (fqn) fulfills.push({ fqn });
    });

    const depends: ContextScope['interfaces']['depends'] = [];
    scopeEl.find('interfaces > depends').each((_, d) => {
      const attrs = (d as Element).attribs || {};
      if (attrs.fqn) {
        depends.push({
          fqn: attrs.fqn,
          facet: attrs.facet,
          usage: attrs.usage,
        });
      }
    });

    scopes.push({
      path,
      interfaces: { fulfills, depends },
      refs: parseRefs($, scopeEl),
      facts: parseFacts($, scopeEl),
      tools: parseTools($, scopeEl),
    });
  });

  return scopes;
}

function parseRefs($: cheerio.CheerioAPI, parent: cheerio.Cheerio<any>): ContextRef[] {
  const refs: ContextRef[] = [];

  parent.find('refs > code').each((_, el) => {
    const attrs = (el as Element).attribs || {};
    if (attrs.file) {
      refs.push({
        file: attrs.file,
        role: attrs.role || 'unknown',
        lines: attrs.lines,
        keys: attrs.keys,
      });
    }
  });

  // Also handle <config> refs
  parent.find('refs > config').each((_, el) => {
    const attrs = (el as Element).attribs || {};
    if (attrs.file) {
      refs.push({
        file: attrs.file,
        role: attrs.role || 'config',
        keys: attrs.keys,
      });
    }
  });

  return refs;
}

function parseFacts($: cheerio.CheerioAPI, parent: cheerio.Cheerio<any>): ContextFact[] {
  const facts: ContextFact[] = [];

  parent.find('facts > fact').each((_, el) => {
    const factEl = $(el as Element);
    const content = factEl.text().trim();
    const decision = (el as Element).attribs?.decision;
    if (content) {
      facts.push({ content, decision });
    }
  });

  return facts;
}

function parseTools($: cheerio.CheerioAPI, parent: cheerio.Cheerio<any>): ContextTool[] {
  const tools: ContextTool[] = [];

  parent.find('tools > tool').each((_, el) => {
    const attrs = (el as Element).attribs || {};
    if (attrs.name) {
      tools.push({
        name: attrs.name,
        scope: attrs.scope || '**',
      });
    }
  });

  return tools;
}
